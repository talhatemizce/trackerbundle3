import os, json
from pathlib import Path
from typing import Dict, Any, Optional

RULES_PATH = Path(os.getenv("RULES_STORE", "/home/ubuntu/trackerbundle3/app/data/rules.json"))
USED_CONDITIONS = ["acceptable", "good", "very_good", "like_new"]

DEFAULTS = {
    "new_max": 50.0,
    "used_all_max": 20.0,
    "used": {},
    "multipliers": {"good_to_very_good": 1.10, "very_good_to_like_new": 1.10},
}

def _normalize_isbn(isbn: str) -> str:
    return (isbn or "").strip()

def _normalize_condition(cond: Optional[str]) -> Optional[str]:
    if cond is None:
        return None
    c = (cond or "").strip().lower().replace("-", "_").replace(" ", "_")
    if c in ("new", "brand_new", "brandnew"):
        return "brand_new"
    if c in ("vg", "verygood"):
        c = "very_good"
    if c in ("ln", "likenew"):
        c = "like_new"
    if c in ("acc", "acceptable"):
        c = "acceptable"
    return c or None

def _coerce_float(x, fallback: float) -> float:
    try:
        return float(fallback) if x is None else float(x)
    except Exception:
        return float(fallback)

def _safe_dict(x) -> dict:
    return x if isinstance(x, dict) else {}

def _derive_used_from_good(used: Dict[str, float], multipliers: Dict[str, float]) -> Dict[str, float]:
    out = dict(used or {})
    good = out.get("good")
    if good is None:
        return out
    g2vg = _coerce_float(multipliers.get("good_to_very_good"), 1.10)
    vg2ln = _coerce_float(multipliers.get("very_good_to_like_new"), 1.10)
    if out.get("very_good") is None:
        out["very_good"] = float(good) * float(g2vg)
    if out.get("like_new") is None and out.get("very_good") is not None:
        out["like_new"] = float(out["very_good"]) * float(vg2ln)
    return out

def load_rules() -> Dict[str, Any]:
    if not RULES_PATH.exists():
        return {"defaults": DEFAULTS.copy(), "overrides": {}}

    try:
        data = json.loads(RULES_PATH.read_text(encoding="utf-8") or "{}")
        defaults_in = _safe_dict(data.get("defaults"))
        overrides_in = _safe_dict(data.get("overrides"))

        if "used_max" in defaults_in and "used_all_max" not in defaults_in:
            defaults_in["used_all_max"] = defaults_in.get("used_max")

        defaults = {
            "new_max": _coerce_float(defaults_in.get("new_max"), DEFAULTS["new_max"]),
            "used_all_max": _coerce_float(defaults_in.get("used_all_max"), DEFAULTS["used_all_max"]),
            "used": _safe_dict(defaults_in.get("used")),
            "multipliers": _safe_dict(defaults_in.get("multipliers")) or DEFAULTS["multipliers"].copy(),
        }

        used_defaults: Dict[str, float] = {}
        for k, v in _safe_dict(defaults.get("used")).items():
            ck = _normalize_condition(k)
            if ck in USED_CONDITIONS and v is not None:
                used_defaults[ck] = _coerce_float(v, 0.0)
        defaults["used"] = _derive_used_from_good(used_defaults, defaults["multipliers"])

        overrides: Dict[str, Any] = {}
        for raw_isbn, v in overrides_in.items():
            isbn = _normalize_isbn(raw_isbn)
            if not isbn or not isinstance(v, dict):
                continue
            ov = dict(v)

            if "used_max" in ov and "used_all_max" not in ov:
                ov["used_all_max"] = ov.get("used_max")

            used_map: Dict[str, float] = {}
            for ck, cv in _safe_dict(ov.get("used")).items():
                nk = _normalize_condition(ck)
                if nk in USED_CONDITIONS and cv is not None:
                    used_map[nk] = _coerce_float(cv, 0.0)

            overrides[isbn] = {
                "new_max": ov.get("new_max"),
                "used_all_max": ov.get("used_all_max"),
                "used": _derive_used_from_good(used_map, defaults["multipliers"]),
            }

        return {"defaults": defaults, "overrides": overrides}
    except Exception:
        return {"defaults": DEFAULTS.copy(), "overrides": {}}

def save_all(rules: Dict[str, Any]) -> Dict[str, Any]:
    RULES_PATH.parent.mkdir(parents=True, exist_ok=True)
    RULES_PATH.write_text(json.dumps(rules, indent=2), encoding="utf-8")
    return rules

def set_defaults(payload: Dict[str, Any]) -> Dict[str, Any]:
    rules = load_rules()
    d = rules["defaults"]

    if payload.get("new_max") is not None:
        d["new_max"] = float(payload["new_max"])
    if payload.get("used_all_max") is not None:
        d["used_all_max"] = float(payload["used_all_max"])

    if isinstance(payload.get("multipliers"), dict):
        d["multipliers"] = {**(d.get("multipliers") or {}), **payload["multipliers"]}

    used = d.get("used") or {}
    if isinstance(payload.get("used"), dict):
        for k, v in payload["used"].items():
            ck = _normalize_condition(k)
            if ck in USED_CONDITIONS and v is not None:
                used[ck] = float(v)

    d["used"] = _derive_used_from_good(used, d.get("multipliers") or DEFAULTS["multipliers"])
    rules["defaults"] = d
    return save_all(rules)

def set_isbn_rule(isbn: str, payload: Dict[str, Any]) -> Dict[str, Any]:
    rules = load_rules()
    isbn = _normalize_isbn(isbn)
    if not isbn:
        return rules

    ov = rules["overrides"].get(isbn) or {"used": {}}
    ov_used = ov.get("used") or {}

    if "new_max" in payload:
        ov["new_max"] = payload["new_max"]
    if "used_all_max" in payload:
        ov["used_all_max"] = payload["used_all_max"]

    if isinstance(payload.get("used"), dict):
        for k, v in payload["used"].items():
            ck = _normalize_condition(k)
            if ck in USED_CONDITIONS:
                if v is None:
                    ov_used.pop(ck, None)
                else:
                    ov_used[ck] = float(v)

    dmult = rules["defaults"].get("multipliers") or DEFAULTS["multipliers"]
    ov["used"] = _derive_used_from_good(ov_used, dmult)
    rules["overrides"][isbn] = ov
    return save_all(rules)

def delete_isbn_rule(isbn: str) -> Dict[str, Any]:
    rules = load_rules()
    rules["overrides"].pop(_normalize_isbn(isbn), None)
    return save_all(rules)

def effective_limit(isbn: Optional[str], condition: str) -> Dict[str, Any]:
    rules = load_rules()
    d = rules["defaults"]
    ov = rules["overrides"].get(_normalize_isbn(isbn or "")) if isbn else None
    c = _normalize_condition(condition) or "used_all"

    if c == "brand_new":
        if ov and ov.get("new_max") is not None:
            return {"kind": "brand_new", "limit": float(ov["new_max"]), "source": "isbn.new_max"}
        return {"kind": "brand_new", "limit": float(d["new_max"]), "source": "defaults.new_max"}

    used_cond = c if c in USED_CONDITIONS else None

    if ov:
        if used_cond and ov.get("used", {}).get(used_cond) is not None:
            return {"kind": "used", "condition": used_cond, "limit": float(ov["used"][used_cond]), "source": f"isbn.used.{used_cond}"}
        if ov.get("used_all_max") is not None:
            return {"kind": "used", "condition": used_cond or "used_all", "limit": float(ov["used_all_max"]), "source": "isbn.used_all_max"}

    if used_cond and d.get("used", {}).get(used_cond) is not None:
        return {"kind": "used", "condition": used_cond, "limit": float(d["used"][used_cond]), "source": f"defaults.used.{used_cond}"}

    return {"kind": "used", "condition": used_cond or "used_all", "limit": float(d["used_all_max"]), "source": "defaults.used_all_max"}
